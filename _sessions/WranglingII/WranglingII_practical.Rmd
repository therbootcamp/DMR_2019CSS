---
title: "Wrangling II"
author: "<table style='table-layout:fixed;width:100%;border:0;padding:0;margin:0'><col width='10%'><col width='10%'>
  <tr style='border:none'>
    <td style='display:block;width:100%;text-align:left;vertical-align:bottom;padding:0;margin:0;border:none' nowrap>
      <font style='font-style:normal'>Explorative Datenanalyse mit R @ CSS</font><br>
      <a href='https://therbootcamp.github.io/EDA_2019CSS/'>
        <i class='fas fa-clock' style='font-size:.9em;' ></i>
      </a>
      <a href='https://therbootcamp.github.io'>
        <i class='fas fa-home' style='font-size:.9em;'></i>
      </a>
      <a href='mailto:therbootcamp@gmail.com'>
        <i class='fas fa-envelope' style='font-size: .9em;'></i>
      </a>
      <a href='https://www.linkedin.com/company/basel-r-bootcamp/'>
        <i class='fab fa-linkedin' style='font-size: .9em;'></i>
      </a>
      <a href='https://therbootcamp.github.io'>
        <font style='font-style:normal'>Basel R Bootcamp</font>
      </a>
    </td>
    <td style='width:100%;vertical-align:bottom;text-align:right;padding:0;margin:0;border:none'>
      <img src='https://raw.githubusercontent.com/therbootcamp/therbootcamp.github.io/master/_sessions/_image/by-sa.png' style='height:15px;width:80px'/>
    </td>
  </tr></table>"
output:
  html_document:
    css: practical.css
    self_contained: no
---

```{r setup, echo = FALSE, message=F, warning=F}
knitr::opts_chunk$set(comment = NA, 
                      fig.width = 6, 
                      fig.height = 6,
                      fig.align = 'center',
                      echo = FALSE, 
                      eval = FALSE, 
                      warning = FALSE)

options(digits = 3)

library(tidyverse)
kc_house <- read_csv("../../1_Data/kc_house.csv")
bev <- read_csv("../../1_Data/bevoelkerung.csv")
basel <- read_csv("../../1_Data/basel.csv")
```

<p align="center">
<img width="100%" src="image/forsale.png" margin=0><br>
<font style="font-size:10px">adapted from [trueloveproperty.co.uk](http://www.trueloveproperty.co.uk/houses-sale-ingham/)</font>
</p>

# {.tabset}

## Überblick

In diesem Practical wirst du das Transformieren, Gruppieren und Analysieren von Daten mit `dplyr` üben.

Am Ende des Practicals wirst du wissen wie man:

1. Daten transformiert
2. Daten gruppiert und deskriptive Statistiken berechnen kann

## Aufgaben

### A - Setup

1. Öffne dein `TheRBootcamp` R project. Es sollte bereits die Ordner `1_Data` und `2_Code` enthalten. Stelle sicher, dass du alle  Datensätze, welche im `Datensätze` Tab aufgelisted sind, in deinem `1_Data` Ordner hast. 

2. Öffne ein neues R Skript. Schreibe deinen Namen, das Datum und "Wrangling II Practical" als Kommentare an den Anfang des Skripts.

```{r, eval = FALSE, echo = TRUE}
## NAME
## DATUM
## Wrangling II Practical
```

3. Speichere das neue Skript unter dem Namen `wrangling_II_practical.R` im `2_Code` Ordner.

4. Lade das `tidyverse` Paket.

```{r, eval = FALSE, echo = TRUE}
# Pakete laden
library(tidyverse)     
```

```{r}
library(tidyverse)
```

### B - Transformation zwischen *Long* und *Wide* Format 

5. In diesem Practical verwenden wir zunächst den `bevoelkerung.csv` Datensatz. Er enthält die Einwohnerzahlen verschiedener schweizer Städte von 1930 bis 2011. Im `Datensätze` Tab findest du eine Auflistung und eine kurze Beschreibung der im Datensatz enthaltenen Variablen. Lese den Datensatz mit der `read_csv()` Funktion in R ein und speichere ihn unter dem Namen `bev`.


```{r eval = FALSE}
bev <- read_csv(file = "1_Data/bevoelkerung.csv")
```


6. Mache dich mit dem Datensatz vertraut in dem du die ersten paar Zeilen und die Variablennamen anschaust.

```{r}
names(bev)
bev
```


7. Im Moment sind die Daten so angeordnet, dass jedes Jahr eine einzelne Spalte hat, also im *Wide* Format. Diese Anordnung ist praktisch zum Eingeben von Daten und um die Daten als Tabelle anzuschauen. Für viele Anwendungen, wie gewisse statistische Analysen oder Plotting, brauchen wir die Daten aber im *Long* format. Für diese Transformation verwenden wir `pivot_longer()`.

Zur Rekapitulation, `pivot_longer()` in der einfachsten "Version" braucht drei Argumente: i) den Datensatz, ii) die Spaltennamen als Spezifikation, welche Spalten vom Wide ins Long Format transformiert werden sollen, und iii) den Spaltennamen der neuen Gruppierungsvariable.

Unter Verwendung nur dieser drei Argumente, transformiere die `st_wbev_2011` und `st_wbev_2001` Variablen aus `bev` vom Wide ins Long Format und speichere das Resultat als neues Objekt `bev_long` ab.

```{r eval = FALSE, echo = TRUE}
# Transofmation vom Wide ins Long Format
bev_long <- bev %>%
  pivot_longer(c("XXX", "XXX"), names_to = "jahr")
```

```{r}
# Transofmation vom Wide ins Long Format
bev_long <- bev %>%
  pivot_longer(c("st_wbev_2011", "st_wbev_2001"), names_to = "jahr")

```

8. Schaue dir den neu erstellten Datensatz an. Versuche nachzuvollziehen was genau gemacht wurde, welche Variablen sich verändert haben und welche nicht. Frage nach, falls du etwas nicht nachvollziehen kannst.

9. Nun da wir die basics verstehen, wollen wir nicht nur die Jahre 2001 und 2011, sondern alle im Datensatz vorhandenen Jahre ins Long Format bringen. Schaue dir dazu erst nochmals die Namen der Variablen an.

```{r}
names(bev)
```

10. Wie du siehst, hat jede Jahr-Variable die gleiche Struktur, nämlich `st_wbev_XXXX`. Dieser Umstand ist hilfreich, da wir dadurch nicht jede Variable explizit auflisten müssen, sondern die `starts_with()` Funktion zur Variablenauswahl verwenden können. Benutze `pivot_longer()` und `starts_with()` um alle Jahr-Variablen zu transformieren.

```{r eval = FALSE, echo = TRUE}
# Transofmation vom Wide ins Long Format
bev_long <- bev %>%
  pivot_longer(starts_with("XXX"), names_to = "jahr")
```

```{r}
bev_long <- bev %>%
  pivot_longer(starts_with("st_"), names_to = "jahr")
```

11. Schaue dir das Resultat an.

12. Die Einwohnerzahl ist im neuen Datensatz in der Spalte `value` enthalten. Dieser Name wird standardmässig gewählt, gibt aber keine Informationen darüber um was für Werte es sich handelt. Wir können einen eigenen Namen wählen, in dem wir in `pivot_longer()` zusätzlich das `values_to` Argument spezifizieren. Wiederhole den Code von Aufgabe 10, und ändere diesen so, dass die Spalte mit den Einwohnerzahlen neu `einwohner` statt `value` heisst.

```{r}
bev_long <- bev %>%
  pivot_longer(starts_with("st_"), names_to = "jahr", values_to = "einwohner")
```


13. Schaue dir das Resultat an. Als letzten Schritt wollen wir noch die Werte der Variable `jahr` so anpassen, dass wir nur die Jahreszahl ohne Präfix haben. `pivot_longer()` bietet mit dem `names_prefix` Argument eine Möglichkeit, Präfixe direkt zu löschen. Dazu spezifizieren wir einfach in Anführungszeichen welcher Teil gelöscht werden soll. Füge zum Code der vorherigen Aufgabe das `names_prefix` Argument hinzu, sodass die `jahr` Variable nur noch die Jahreszahl enthält.


```{r}
bev_long <- bev %>%
  pivot_longer(starts_with("st_"), names_to = "jahr", values_to = "einwohner",
               names_prefix = "st_wbev_")
```

14. Nun können wir mit dem neu erstellten Datensatz arbeiten und, zum Beispiel, einen Plot erstellen. Plotting werden wir zu einem späteren Zeitpunkt behandeln, daher unten nur ein kleines Codebeispiel zur Generierung eines Plots. Führe den Code aus und schaue dir die Entwicklung der Einwohnerzahlen an.


```{r eval = FALSE, echo = TRUE}
# generiere ein leeres Plot fenster mit den spezifizierten Variablen auf den Achsen
ggplot(bev_long, aes(as.numeric(jahr), log(einwohner, base = 10),
                     # gruppiere gemäss der Stadtname variable; nötig um separate 
                     # Linien pro Stadt zu erhalten
                     group = Stadtname)) +
  # füge die Datenpunkte hinzu
  geom_point(alpha = .6) +
  # verbinde die Datenpunkte pro Stadt
  geom_line(alpha = .3) +
  # sopezifiziere die Achsenbeschriftungen 
  labs(x = "Jahr", y = expression("log"[10]*"(Einwohner)")) + 
  scale_x_continuous(breaks = c(1930, 1970, 1980, 1990, 2000, 2001, 2011)) +
  # spezifiziere Plot layout
  theme_classic() +
  theme(axis.text.x = element_text(angle=45, size = 12, hjust = 1),
        axis.text.y = element_text(size = 12),
        axis.title = element_text(size = 14))
  
```

```{r echo = FALSE, fig.width=12}
# generiere ein leeres Plot fenster mit den spezifizierten Variablen auf den Achsen
ggplot(bev_long, aes(as.numeric(jahr), log(einwohner, base = 10),
                     # gruppiere gemäss der Stadtname variable; nötig um separate 
                     # Linien pro Stadt zu erhalten
                     group = Stadtname)) +
  # füge die Datenpunkte hinzu
  geom_point(alpha = .6) +
  # verbinde die Datenpunkte pro Stadt
  geom_line(alpha = .3) +
  # sopezifiziere die Achsenbeschriftungen 
  labs(x = "Jahr", y = expression("log"[10]*"(Einwohner)")) + 
  scale_x_continuous(breaks = c(1930, 1970, 1980, 1990, 2000, 2001, 2011)) +
  # spezifiziere Plot layout
  theme_classic() +
  theme(axis.text.x = element_text(angle=45, size = 12, hjust = 1),
        axis.text.y = element_text(size = 12),
        axis.title = element_text(size = 14))
  
```

15. Wie bereits geschildert, ist das Long Format für viele Analysen und Visualisierungen besser geeignet. Es gibt jedoch auch Situationen, in denen das Wide Format praktischer ist; zum Beispiel, wenn wir die Veränderung der Einwohnerzahlen zwischen 1930 und 2011 berechnen wollen. Lass uns für diese Übung so tun, als ob wir die Daten nur im Long Format (`bev_long`) hätten und sie daher zuerst ins Wide Format umwandeln müssten. Dazu verwenden wir `pivot_wider()` und spezifizieren die Argumente `names_from`, `values_from`. Speichere das Ergebnis unter `bev_wide` ab.

 
```{r eval = FALSE, echo = TRUE}
# Transofmation vom Long ins Wide Format
bev_wide <- bev_long %>%
  pivot_wider(names_from = XXX, values_from = XXX)
```

```{r}
bev_wide <- bev_long %>%
  pivot_wider(names_from = jahr, values_from = einwohner)
```

16. Vergleiche `bev_wide` mit `bev`. War die Rücktransformation erfolgreich? Was fehlt?

17. Um die zuvor entfernten Präfixe wieder bei den Variablennamen hinzuzufügen, kannst du das `names_prefix` argument in `pivot_wider()` verwenden. Benutze `names_prefix` um `"st_wbev_"` als Präfix hinzuzufügen. 

```{r}
bev_wide <- bev_long %>%
  pivot_wider(names_from = jahr, values_from = einwohner,
              names_prefix = "st_wbev_")
```

18. Berechne nun die Differenz in den Einwohnerzahlen zwischen 1930 und 2011 für alle Städte und zeige den Mittelwert dieser Variable an. Entferne dabei zuerst die Zahlen für die gesamte Schweiz mit Hilfe der `filter()` Funktion und dem `!=` (ungleich Operator). Berechne dann die Differenzen und speichere sie als neue Variable `delta`. Da die `mean()` Funktion einen Vektor als Input verlangt, verwenden wir `pull()` um den Mittelwert der `delta` Variable zu berechnen.

```{r eval = FALSE, echo = TRUE}
bev_wide %>%
  filter(XXX != "XXX") %>%
  mutate(XXX = XXX - XXX) %>%
  pull(XXX) %>%
  mean(na.rm = TRUE)
```

```{r}
bev_wide %>%
  filter(Stadtname != "Schweiz") %>%
  mutate(delta = st_wbev_2011 - st_wbev_1930) %>%
  pull(delta) %>%
  mean(na.rm = TRUE)
```

19. Die vorherige Aufgabe soll unter anderem verdeutlichen, wie `pull()` funktioniert. Eine andere Möglichkeit die obige Berechnung anzustellen wäre mit Hilfe der `summarise()` Funktion. Wiederhole die Berechung, diesmal mit `summarise()` und vergleiche den Output mit dem der vorherigen Aufgabe

```{r eval = FALSE, echo = TRUE}
bev_wide %>%
  filter(XXX != "XXX") %>%
  mutate(XXX = XXX - XXX) %>%
  summarise(delta_m = mean(XXX, na.rm = TRUE))
```

```{r}
bev_wide %>%
  filter(Stadtname != "Schweiz") %>%
  mutate(delta = st_wbev_2011 - st_wbev_1930) %>%
  summarise(delta_m = mean(delta, na.rm = TRUE))
```

### B - Wiederholung Wrangling I


1. Für den Rest des Practicals verwenden wir den `kc_house.csv` Datensatz. Er enthält Verkaufspreise von Häusern in King County, Washington. Aufgelistet sind Häuser, welche zwischen Mai 2014 und Mai 2015 verkauft wurden. Nebst den Verkaufspreisen enthält der Datensatz Spezifikationen der Häuser, z.B. die Anzahl Zimmer eines Hauses. Lese den Datensatz mit der `read_csv()` Funktion in R ein und speichere ihn unter dem Namen `kc_house`.


```{r, eval = FALSE}
kc_house <- read_csv(file = "1_Data/kc_house.csv")
```

2. Exploriere den Datensatz um einen Eindruck über dessen Struktur zu erhalten.

```{r}
kc_house
summary(kc_house)
```


3. Schaue dir mit der `names()` Funktion die Variablennamen an.

```{r}
names(kc_house)
```


4. Da es sich um einen US Datensatz handelt, sind die Flächenangaben in Quadratfuss angegeben. Wir als "rest of the world" sind es eher gewohnt in Quadratmeter zu denken. Kreiere dazu drei neue Variablen `qm_wohnraum`, `qm_dachstock` und `qm_keller`, welche die jeweilige Raumgrösse in Quadratmeter angeben (Tipp: ein Quadratfuss entspricht 0.093 Quadratmeter).

```{r eval = FALSE, echo = TRUE}
kc_house <- kc_house %>%
  mutate(XXX = XXX * 0.093,
         XXX = XXX * 0.093,
         XXX  = XXX * 0.093)
```

```{r, eval = TRUE}
kc_house <- kc_house %>%
  mutate(qm_wohnraum = qf_wohnraum * 0.093,
         qm_dachstock = qf_dachstock * 0.093,
         qm_keller  = qf_keller * 0.093)
```

5. Kreiere eine neue Spalte `qm_total`, welche die Summe aus `qm_wohnraum`, `qm_dachstock` und `qm_keller` darstellt.

```{r, eval = TRUE}
kc_house <- kc_house %>%
  mutate(qm_total = qm_wohnraum + qm_dachstock + qm_keller)
```

6. Füge eine neue Variable `villa` hinzu, welche den Wert "ja" annimmt, wenn `qm_total` grösser als 750 ist und "nein", wenn `qm_total` kleiner oder gleich 750 ist.

```{r, eval = TRUE}
kc_house <- kc_house %>%
                mutate(villa = case_when(
                              qm_total > 750 ~ "ja",
                              qm_total <= 750~ "nein"))
```


### C - Einfache deskriptive Statistiken

1. Unter Verwendung der base-R `data$col` Notation, berechne den Mittelwert über alle Hauspreise.

```{r}
mean(kc_house$preis)
```

2. Wiederhole die vorherige Aufgabe, diesmal unter Verwendung der `summarise()` Funktion. Worin besteht der Unterschied der Resultate dieser und der vorherigen Aufgabe?

```{r}
kc_house %>%
  summarise(
    preis_mean = mean(preis)
  )

# In der ersten Aufgabe war das Ergebnis eine einzelne Zahl, also ein Vektor mit nur
# einem Element. In der zweiten Aufgabe war das Ergebnis ein tibble mit nur einem
# Eintrag.
```

3. Wie hoch ist der *Median*preis aller Häuser? Benutze dazu die `median()` Funktion. Worin besteht der Unterschied zwischen dem Mittelwert und dem Median?

```{r}
kc_house %>%
  summarise(
    preis_median = median(preis)
  )

# Der Mittelwert gibt den Durschnittspreis an, also die Summe aller Preise geteilt durch die
# Anzahl berücksichtigter Preise. Der Median gibt das 50. Perzentil der Preise an, also 
# den Preis, der, wenn wir die Preise aufsteigend sortieren, an der Position steht, an der 
# sowohl nach oben als auch nach unten gleich viele Preise stehen. Dadurch ist der Median
# robuster gegenüber ausreissern.

```

4. Wie hoch ist der höchste Verkaufspreis? Tipp: das Maximum eines Vektors findest du mit der `max()` Funktion.

```{r}
kc_house %>%
  summarise(
    preis_max = max(preis)
  )
```

5. Sortiere mittels der `arrange()` und der `desc()` Funktion den Datensatz nach `preis` in absteigender Reihenfolge und printe das Resultat. Du kannst kontrollieren ob es geklappt hat, in dem du überprüfst ob der höchste Verkaufspreis, den du in der letzten Aufgabe herausgefunden hast, zuoberst erscheint.


```{r}
kc_house <- kc_house %>%
  arrange(desc(preis))

kc_house
```

6. Wie gross ist der Anteil an Häuser, welche für mehr als 1 Million USD verkauft wurden? Erinnere: `TRUE` und `FALSE` werden von R als 1 respektive 0 interpretiert. Wenn wir daher den Mittelwert eines Vektors mit `TRUE` und `FALSE` berechnen, erhalten wir den Anteil `TRUE`s (Beispiel: `mean(c(TRUE, TRUE, FALSE, TRUE))` ergibt 0.75).

```{r eval = FALSE, echo = TRUE}
kc_house %>%
  summarise(mil_p = mean(XXX > XXX))
```

```{r}
kc_house %>%
  summarise(mil_p = mean(preis > 1000000))
```

7. Berechne die mittlere Anzahl Stockwerke (`stoecke`) und Badezimmer (`badezimmer`) von Villen (`villa`).


```{r}
kc_house %>%
  filter(villa == "ja") %>%
  summarise(
    stoecke_mean = mean(stoecke),
    badezimmer_mean = mean(badezimmer)
  )
```

### D - Einfache gruppierte deskriptive Statistiken 

1. Erstelle eine Tabelle, welche dir anzeigt wie viele Villen und wie viele normale Häuser (nicht-Villen) im Datensatz vorhanden sind. Benutze hierzu `group_by()` zur Gruppierung nach Villen (`villa`) und `n()` zur Berechnung der jeweiligen Anzahl.


```{r eval = FALSE, echo = TRUE}
kc_house %>%
  group_by(XXX) %>%
  summarise(N = XXX)
```

```{r}
kc_house %>%
  group_by(villa) %>%
  summarise(N = n())
```

2. Wie hoch ist der mittlere Verkaufspreis von Villen und normalen Häusern (nicht-Villen)?


```{r}
kc_house %>%
  group_by(villa) %>%
  summarise(N = n(),
            preis_mean = mean(preis))
```

3. Verwende `group_by()` und `summarise()` um die untenstehende Tabelle zu erhalten.

```{r, echo = FALSE, eval = TRUE, results = 'asis'}
kc_house %>%
  group_by(villa) %>%
  summarise(N = n(),
            preis_min = min(preis),
            preis_mean = mean(preis),
            preis_median = median(preis),
            preis_max = max(preis)) %>%
  knitr::kable()
```


```{r}
kc_house %>%
  group_by(villa) %>%
  summarise(N = n(),
            preis_min = min(preis),
            preis_mean = mean(preis),
            preis_median = median(preis),
            preis_max = max(preis))
```

4. Haben Häuser, welche später gebaut wurden, eine grössere Wohnfläche? Gruppiere zur Beantwortung dieser Frage die Daten nach `baujahr` und berechne dann die mittlere Wohnfläche (`qm_wohnraum`).

```{r}
kc_house %>%
  group_by(baujahr) %>%
  summarise(N = n(),
            wohnraum = mean(qm_wohnraum))
```

5. Diese Tabelle hat recht viele Zeilen und ist daher etwas unübersichtlich. Kreiere eine neue Variable `baujahrzehnt`, welche angibt, in welchem Jahrzehnt ein Haus gebaut wurde und erstelle dann die Tabelle der letzten Aufgabe Gruppiert nach dieser neuen Variable. Tipp: die `floor()` Funktion rundet eine Zahl auf die nächst kleinere ganze Zahl ab.


```{r}
kc_house %>%
  mutate(baujahrzehnt = floor(baujahr / 10)) %>%
  group_by(baujahrzehnt) %>%
  summarise(N = n(),
            wohnraum = mean(qm_wohnraum))
```

### E - Mehrere Gruppen

1. Dein Freund Theodorus interessiert sich für Häuser einer bestimmten Gegend, nämlich mit den Postleitzahlen (`postleitzahl`) 98001, 98109, 98117 und 98199. Stelle ihm einen neuen Datensatz `theodorus` zusammen, welcher nur die Häuser dieser Gegend enthält. Tipp: der `%in%` Operator testet ob Elemente des Vektors auf der rechten Seite im Vektor auf der linken Seite enthalten sind.

```{r}
theodorus <- kc_house %>%
  filter(postleitzahl %in% c(98001, 98109, 98117, 98199))
```

2. Berechne für Theodorus den mittleren, den Median-, den Minimum-, den Maximumpreis, sowie die Anzahl Häuser pro Gruppe, separat für die Postleitzahlen und ob es eine Villa ist.

```{r}
theodorus %>%
  group_by(postleitzahl, villa) %>%
  summarise(preis_mean = mean(preis),
            preis_median = median(preis),
            stoecke_min = min(stoecke),
            stoecke_max = max(stoecke),
            N = n())
```


### X - Challenges

1. Welche Postleitzahl hat den höchsten Anteil Häuser, welche am Ufer gebaut sind (`ufer`)? Printe nur diese Zeile des Datensatzes.

```{r}
kc_house %>%
  group_by(postleitzahl) %>%
  summarise(ufer_p = mean(ufer)) %>%
  arrange(desc(ufer_p)) %>%
  slice(1)
```

2. Welches Haus hat das schlechteste Preis-Wohnraumgrösse Verhältnis? Printe nur diese Zeile des Datensatzes.

```{r}
kc_house %>%
  mutate(preis_zu_flaeche = preis / qm_wohnraum) %>%
  arrange(desc(preis_zu_flaeche)) %>%
  slice(1)
```

3. Welche 10 Postleitzahlen haben im Schnitt die höchsten Hauspreise? Printe nur diese 10 Zeilen.

```{r}
kc_house %>%
  group_by(postleitzahl) %>%
  summarise(preis_mean = mean(preis)) %>%
  arrange(desc(preis_mean)) %>%
  slice(1:10)
```

4. Kreiere den folgenden Datensatz *genau* wie er unten steht.

```{r, eval = FALSE, echo = FALSE}
kc_house %>%
  filter(baujahr >= 1990 & baujahr < 1999) %>%
  group_by(baujahr) %>%
  summarise(N = n(),
            preis_mean = mean(preis),
            preis_max = max(preis),
            qm_wohnraum_mean = mean(qm_wohnraum)) %>%
  knitr::kable(digits = 0)
```

| baujahr|   N| preis_mean| preis_max| qm_wohnraum_mean|
|--------:|---:|----------:|---------:|---------------:|
|     1990| 320|     563966|   3640900|             234|
|     1991| 224|     630441|   5300000|             244|
|     1992| 198|     548169|   2480000|             223|
|     1993| 202|     556612|   3120000|             226|
|     1994| 249|     486834|   2880500|             209|
|     1995| 169|     577771|   3200000|             224|
|     1996| 195|     639534|   3100000|             240|
|     1997| 177|     606058|   3800000|             234|
|     1998| 239|     594159|   1960000|             241|

```{r}
kc_house %>%
  filter(baujahr >= 1990 & baujahr < 1999) %>%
  group_by(baujahr) %>%
  summarise(N = n(),
            preis_mean = mean(preis),
            preis_max = max(preis),
            qm_wohnraum_mean = mean(qm_wohnraum)) %>%
  knitr::kable(digits = 0)
```


## Beispiele

```{r, eval = FALSE, echo = TRUE}
# Wrangling II mit dplyr and tidyr ---------------------------

library(tidyverse)    # Lade tidyverse für dplyr

# Lese den basel Datensatz ein
basel <- read_csv("1_Data/basel.txt")

# Keine Gruppierungsvariable
bas <- basel %>%
  summarise(
    alter_m = mean(alter, na.rm = TRUE),
    einkommen_median = median(einkommen, na.rm = TRUE),
    N = n()
  )

bas

# Eine Gruppierungsvariable
bas_ges <- basel %>%
  group_by(geschlecht) %>%
  summarise(
    alter_m = mean(alter, na.rm = TRUE),
    einkommen_median = median(einkommen, na.rm = TRUE),
    N = n()
  )

bas_ges

# Zwei Gruppierungsvariablen
bas_ges_bil <- basel %>%
  group_by(geschlecht, bildung) %>%
  summarise(
    alter_m = mean(alter, na.rm = TRUE),
    einkommen_median = median(einkommen, na.rm = TRUE),
    N = n()
  )

bas_ges_bil

# Gruppiere nach Geschlecht und Bildung und berechne den Mittelwert aller 
# Variablen des Typs numeric
basel %>%
  group_by(geschlecht, bildung) %>%
  summarise_if(is.numeric, mean, na.rm = TRUE)

```

## Datensätze

|File | Zeilen | Spalten | Beschreibung |
|:----|:-----|:------|:-----------------------------------------|
|[kc_house.csv](https://raw.githubusercontent.com/therbootcamp/BaselRBootcamp_2018July/master/_sessions/_data/baselrbootcamp_data/kc_house.csv) | 21613 | 11|Verkaufspreise von Häusern in King County zwischen Mai 2014 und Mai 2015. |
|[bevoelkerung.csv](https://raw.githubusercontent.com/therbootcamp/BaselRBootcamp_2018July/master/_sessions/_data/baselrbootcamp_data/kc_house.csv) | 161 | 10|Einwohnerzahlen schweizer Städte von 1930 bis 2011. |

#### kc_house.csv

*Erste 5 Zeilen und 5 Spalten von kc_house.csv*

```{r, eval = TRUE, echo = FALSE}
knitr::kable(kc_house[1:5, 1:5])
```

|Variable | Beschreibung |
|:--------|:-----------------------------|
|preis  | Preis in USD| 
|schlafzimmer    | Anzahl Schlafzimmer|
|badezimmer   | Anzahl Badezimmer|
|qf_wohnraum | Wohnraumfläche in Quadratfuss|
|qf_parzelle | Parzellengrösse in Quadratfuss|    
|stoecke   |Anzahl Stöcke|
|ufer | Ist das Haus am Ufer gebaut (1) oder nicht (0)|
|qf_dachstock | Dachstockfläche in Quadratfuss|
|qf_keller | Kellerfläche in Quadratfuss|
|baujahr | Baujahr|
|postleitzahl | Postleitzahl|


#### bevoelkerung.csv

*Erste 5 Zeilen und 5 Spalten von bevoelkerung.csv*

```{r, eval = TRUE, echo = FALSE}
knitr::kable(bev[1:5, 1:5])
```

|Variable | Beschreibung |
|:--------|:-----------------------------|
|Stadtname  |Name der Stadt|
|st_wbev_2011  |Wohnbevölkerung im Jahr 2011|
|st_wbev_2001  | Wohnbevölkerung im Jahr 2001| 
|proz_ver-2001–2011    | Veränderung der Einwohnerzahl in Prozent zwischen 2001 und 2011|
|bevdichte   | Bevölkerungsdichte|
|st_wbev_1930 | Wohnbevölkerung im Jahr 1930|
|st_wbev_1970 | Wohnbevölkerung im Jahr 1970|    
|st_wbev_1980   |Wohnbevölkerung im Jahr 1980|
|st_wbev_1990 | Wohnbevölkerung im Jahr 1990|
|st_wbev_2000 | Wohnbevölkerung im Jahr 2000|


## Funktionen

### Pakete

|Paket| Installation|Beschreibung|
|:------|:------|:------|
|`tidyverse`|`install.packages("tidyverse")`|Ein Metapaket für Data Science, einschliesslich `dplyr`, `ggplot2` und weitere Pakete|

### Funktionen

*Wrangling*

| Funktion| Paket | Beschreibung |
|:---|:------|:---------------------------------------------|
|     `rename()`|`dplyr`|    Umbenennen von Spalten| 
|     `select()`|`dplyr`|    Auswahl von Spalten basierend auf Name oder Index| 
|     `filter()`|`dplyr`|    Auswahl von Zeilen basieren auf einem logischen Ausdruck| 
|     `arrange()`|`dplyr`|    Sortiere Zeilen| 
|     `mutate()`|`dplyr`|    Hinzufügen von Spalten|
|     `case_when()`|`dplyr`|    Recodieren von Spalten| 
|     `group_by(), summarise()`|`dplyr`|   Gruppierung von Daten zur Berechnung deskriptiver Statistiken|
|     `pivot_longer()`|`tidyr`|   Transormation vom Wide ins Long Format|
|     `pivot_wider()`|`tidyr`|   Transormation vom Long ins Wide Format|



## Ressourcen

### `dplyr` Vignette

Hier geht es zur [dplyr Vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html).

Hier geht es zur [tidyr Vignette](https://www.tidyverse.org/blog/2019/09/tidyr-1-0-0/).


### Cheatsheets

<p align="center" width="100%">
<a href="https://github.com/rstudio/cheatsheets/raw/master/translations/german/data-wrangling-german.pdf">
  <img src="image/wrangling_german.png" style="width:70%"></a>
  <br>
  <font style="font-size:10px">von <a href="https://www.rstudio.com/resources/cheatsheets/">R Studio</a></font>
</p>
